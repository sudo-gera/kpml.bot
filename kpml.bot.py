

#основной код работы сервиса kpml.bot, для понимания работы некоторых компонентов следует почитать документацию вк, расположеннцю по адреcу https://vk.com/dev/manuals
from urllib.request import urlopen
from json import loads
from json import dumps
from urllib.parse import quote
from time import sleep
from time import time
from time import asctime
from traceback import format_exc as error
from os import popen
from os import listdir
from random import shuffle

#исполнение всех файлов, которые начинаются с kpml.
#в таких файлах рекомендуется описывать объявление переменных и функций, а сами действия писать здесь
for w in listdir('.'):
 if w[:5]=='kpml.' and w!='kpml.bot.py':
  exec(open(w).read())

yis=31536000 # year in seconds
#некоторые константы


try:
 db=loads(open('../kpml.bot.db.json').read())
except:
 db=loads('{}')
#открытие базы данных с информацией кому что когда присылать (профили пользователей)

admin=['225847803','382227482']
#список id администрации, это люди, которые получают оповещения об ошибках. Дополнительных полномочий наличие в этом списке не даёт

#userwork######################################################
definf={
 'need':1,
#1 или 0: нужны ли сообщения (или пользователь отключил рассылку)
 'until':time()+yis*32,
#сколько хранить данные в секундах (во избежание переполнения базы данных
 'class':[],
#список классов, на которые подписан пользователь
 'time':[],
#список времён для оповещения (в секундах, с начала суток, лондонское время)
 'ls':0,
#вермя, когда было отправлено последнее рассылочное сообщение пользователю
 'dis_empty':1,
#1 или 0: верно ли что пользователь отключил пустые сообщения
 'lm':today()[2]-(0 if today()[1]>5 else 1)
#год, когда произошла ежегодная смена значения класса на 1 класс вверх, по умолчанию ставится этот год если это начало года (перевода ещё не было) и предыдущий, если конец (перевод был)
 }
#список полей, которые должны содержаться в профиле каждого пользователя, а так же значения полей по умолчанию


if 1:
 tn=time()
 #tn содержит текущее время, во избежание вызова time() много раз (это может быть долго, а миллисекундная точность не важна)
 #пройти по списку пользователей и обновить информацию профиля
 for cdb in db:
  #cdb - текущий профиль (например, вк)
  for w in db[cdb]:
   #w - id пользователя
   #проходим по списку полей профиля и заполняем значениями по умолчанию те, которых нет
   for e in definf:
    if e not in db[cdb][w]:
     db[cdb][w][e]=definf[e]
   #если пора удалять информацию, это делается здесь.
   if tn>db[cdb][w]['until']:
    delete(db[cdb][w])
   #перевод всех на класс выше
   if today()[2]-db[cdb][w]['lm']>0 and today()[1]>5:
    f=[]
    for e in db[cdb][w]['class']:
     i=''
     while e and e[0].isdigit():
      i+=e[0]
      e=e[1:]
     i=str(int(i)+1)
     e=i+e
     f+=[e]
    if db[cdb][w]['need']:
     send('теперь вы подписаны классы: \n'+' '.join(f)+'\nраньше вы были подписаны на классы: \n'+' '.join(db[cdb][w]['class'])+'\nЕсли вы завершили обучение в лицее, перейдите в настройки и отключите оповещения',defkey,w,cdb)
    db[cdb][w]['class']=f[:]
    db[cdb][w]['lm']=today()[2]
#mainloop#########################################################
#бот ходит по этому циклу, пока не получит соообщения
 wai=[]
 loopstart=time()
 #массив для сообщений
 while wai==[]:
  tn=int(time())
  #нужно ли кого-то оповестить
  for cdb in db:
   for w in db[cdb].keys():
    if w.isdigit():
     #проход по всем пользователям
     for e in db[cdb][w]['time']:
      #если с момента, когда надо было отправить сообщение прошло не более 5 минут и с последней рассылочной отправки прошло не менее 5 минут (не факт, что этот фрагмент кода выполнится именно в назначенное время, поэтому нужно допускать погрешность)
      if 0 < tn % (24*3600) - int(e) < 300 and tn - db[cdb][w]['ls'] >= 300:
       worked=work(w,cdb,db[cdb][w]['dis_empty'])
       if worked:
        send(worked,defkey,w,cdb)
        db[cdb][w]['ls']=int(time())
  wai=look()
  if wai==[] and tn-loopstart>16:
   sleep(10)
#gotmess###########################################################
#сообщене получено
 shuffle(wai)
 for q in wai:
  #цикл по полученным сообщениям. Ниже рассматривается каждое. Формат: [автор (обычно id), текст, платформа(например вк)]
  #сначала нужно проверить верность профиля пользователя
  print(q)
  added=0
  if q[2] not in db.keys():
   db[q[2]]=dict()
  if q[0] not in db[q[2]].keys():
   db[q[2]][q[0]]=dict()
   added=1
  for w in definf:
   if w not in db[q[2]][q[0]]:
    db[q[2]][q[0]][w]=definf[w]
   continue
  current_profile=db[q[2]][q[0]]
  #при присвоени словаря передаётся указатель на него а не копия
#logic###############################################################
#теперь можно приступать к пониманию, чего хотел пользователь
  if q[1] == '':
   send('текстом, пожалуйста')
  elif q[1] == 'json':
   send(str(db).replace("'",'"'))
  elif q[1] == 'git':
   t=popen('git show').read()
   t=t.split('\n\n')[0]
   send(t)
  elif q[1] == 'len':
   send(len(db[q[2]].keys()))
  elif q[1] == 'sub':
   send(len([w for w in db[q[2]] if 'time' in db[q[2]][w] and db[q[2]][w]['time']]))
  elif q[1] == '.':
   send('.')
  elif q[1] == 'gl':
   send(globals())
  elif q[1] == 'xg':
   send('\n'.join(['vk.com/id'+w+' '+str(db[q[2]][w]) for w in db[q[2]].keys()]))
  elif q[1] == 'sw':
   send('\n'.join(['vk.com/id'+w+' class: '+str(db[q[2]][w]['class'] if 'class' in db[q[2]][w] else 0)+' time: '+str([str(e//3600+3)+':'+str(e//60%60) for e in (db[q[2]][w]['time'] if 'time' in db[q[2]][w] else [])]) for w in db[q[2]].keys()]))
  elif q[1] == 'отмена':
   send('отменено')
  elif q[1] in ['получить изменения','сейчас']:
   tmp=view()
   tmp=tmp
   send(tmp)
  elif q[1] == 'отключить пустые сообщения' or q[1] == 'пусто' and current_profile['dis_empty']==0:
   current_profile['dis_empty']=1
   send('теперь вам не будут приходить автоматические оповещения, если они не содержат изменений. Обратите внимание, что иногда вам всё же будут приходить пустые оповещения, сообщайте о таких ошибках и они будут исправлены.')
  elif q[1] == 'включить пустые сообщения' or q[1] == 'пусто' and current_profile['dis_empty']==1:
   current_profile['dis_empty']=0
   send('теперь вам будут приходить автоматические оповещения строго по расписанию, даже если в них ничего нет.')
  elif q[1] == 'сообщение об ошибке':
   send('напишите сообщение об ошибке, начните его с символа $',backey)
  elif q[1][0] == '$':
   log('сообщение об ошибке\nавтор '+getlink(q)+'\n'+q[1][1:])
   send('спасибо за обращение. Именно благодаря вам этот сервис скоро станет лучше. сообщение отправлено администрации, с вами скоро свяжутся')
  elif q[1] == 'lookall':
   send(work(q[0],q[2]))
  elif isdt(q[1]):
   tmp=isdt(q[1])
   tmp=view(tmp[0],tmp[1],q[0],q[2])
   tmp='\n'.join(tmp)
   tmp='Изменения на '+q[1]+':\n'+tmp
   send(tmp)
  elif iskcl(q[1]):
   q[1]=q[1].replace('\u2000','')
   q[1]=q[1].upper()
   current_profile['class']=[q[1]]
   send('теперь вы подписаны на класс '+q[1])
  elif isktm(q[1]):
   q[1]=q[1].replace('\u205a',':')
   ms=q[1]
   q[1]=q[1].split(':')
   q[1]=(int(q[1][0])-3)%24*3600+int(q[1][1])%60*60
   current_profile['time']=[q[1]]
   send('теперь вы будете узнавать об изменениях в '+ms)
  elif istm(q[1]):
   ms=q[1]
   q[1]=q[1].split(':')
   q[1]=(int(q[1][0])-3)%24*3600+int(q[1][1])%60*60
   if q[1] in current_profile['time']:
    current_profile['time']=[w for w in current_profile['time'] if w != q[1]]
    t='количество оповещений в день уменьшено временем '+ms
   else:
    if len(current_profile['time']) >= 256:
     t='вы не можете получать более чем 256 уведомлений в сутки'
    else:
     current_profile['time']+=[q[1]]
     t='количество оповещений в день увеличено временем '+ms
   send(t+'. Обратие внимание, что оповещение не содержит изменений, опубликованных позднее, чем оно пришло')
  elif q[1] in ['изменить кол-во оповещений в день','время']:
   ts=current_profile['time'][:]
   ts=[str((w//3600+3)%24)+':'+str(w%3600//60) for w in ts]
   lts=len(ts)
   ts='\n'.join(ts)
   if ts:
    ts='Сейчас вам приходят оповещения '+str(lts)+' раз в день по этому расписанию:\n'+ts+'''
введите интересующее вас время,
если оно в расписании, то оно будет убрано от туда,
если его там нет, то добавлено.
Бот не способен оповещать чаще, чем раз в 5 минут
'''
   else:
    ts='Сейчас вам не приходят оповещения, введите время для оповещения'
   send(ts,backey)
  elif q[1]=='указать класс':
   send('выберите свой класс',clskey)
  elif q[1]=='указать время':
   send('выберите, когда вас оповещать. Обратите внимание, что оповещение не содержит измений, опубликованных позднее. Любое время, которого здесь нет можно указать через расширенные настройки',timkey)
  elif q[1]=='настройки':
   send('панель настроек поможет настроить бота под себя',optkey)
  elif q[1]=='расширенные настройки':
   send('панель настроек поможет более точно настроить бота под себя',setkey)
  elif q[1]=='help':
   send('''
чтобы изменить кол-во отслеживаемых классов напиши слово класс
чтобы изменить кол-во оповещений в день напиши слово время
чтобы получить изменения прямо сейчас напиши слово сейчас
чтобы включить или отключить пустые сообщения напиши слово пусто
чтобы сообщить об ошибке напиши сообщение, начав его с символа $
  ''')
  elif iscl(q[1]):
   q[1]=q[1].upper()
   ms=q[1]
   if q[1] in current_profile['class']:
    current_profile['class']=[w for w in current_profile['class'] if w != q[1]]
    t='количество отслеживаемых классов уменьшено классом '+ms+'.'
   else:
    if len(current_profile['class'])>=256:
     t='вы не можете подписаться более чем на 256 классов'
    elif len(q[1]) > 16:
     t='длина класса не может превышать 16 символов'
    else:
     current_profile['class']+=[q[1]]
     t='количество отслеживаемых классов увеличено классом  '+ms+'.'
   send(t)
  elif q[1] in ['изменить кол-во отслеживаемых классов','класс']:
   ts=current_profile['class'][:]
   lts=len(ts)
   ts='\n'.join(ts)
   if ts:
    send('Сейчас вы подписаны на '+str(lts)+' классов:\n'+ts+'\n Введите класс, который вас интересует, если вы подписаны на него, то будете отписаны, если подписаны не были, то будете подписаны. Вводить класс следует указав номер и букву без пробела, если в параллели один класс, то это класс "а". Используйте только русские буквы, а не их латинские аналоги',backey)
   else:
    send('Сейчас вы не подписаны ни на один из классов. Введите класс, на который хотите подписаться.  Вводить класс следует узазав номер и букву без пробела, если в параллели один класс, то это класс "а". Используйте только русские буквы, а не их латинские аналоги',backey)
  elif q[1]=='отключить рассылку':
   current_profile['until']=time()+yis
   current_profile['need']=0
   send('рассылка отключена, однако, вы всё ещё можете получать изменения по нажатии на кнопку. Если вы не включите её в течение года, информация о ваших настройках бота будет удаена')
  elif q[1]=='включить рассылку':
   current_profile['need']=1
   current_profile['until']=time()+yis*32
   send('рассылка включена')
  else:
   send('''Привет, это бот-оповещатель об изменениях в расписании.
Бота надо настроить, чтобы он знал, в каком вы классе и во сколько вас оповещать.
Для этого укажи, сколько раз в день тебе сообщать об изменениях, и за изменениями для каких классов ты хочешь следить.
Клавиатура поможет тебе в этом.
если твоё приложение не поддерживает работу с клавиатурами, то напиши мне команду help
''')
#запись базы данных после успешного завершения программы
open('../kpml.bot.db.json','w').write(dumps(db))


