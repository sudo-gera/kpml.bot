

# основной код работы сервиса kpml.bot, для понимания работы некоторых
# компонентов следует почитать документацию вк, расположенную по адреcу
# https://vk.com/dev/manuals
from json import loads
from json import dumps
from time import sleep
from time import time
from os import popen
from os import listdir
from random import shuffle

# исполнение всех файлов, которые начинаются с kpml.
# в таких файлах рекомендуется описывать объявление переменных и функций,
# а сами действия писать здесь
for w in listdir('.'):
    if w[:5] == 'kpml.' and w != 'kpml.bot.py':
        exec(open(w).read())

yis = 31536000  # year in seconds
# некоторые константы


try:
    db = loads(open('../kpml.bot.db.json').read())
except BaseException:
    db = loads('{}')
# открытие базы данных с информацией кому что когда присылать (профили
# пользователей)

admin = ['225847803', '382227482']
# список id администрации, это люди, которые получают оповещения об
# ошибках. Дополнительных полномочий наличие в этом списке не даёт

#userwork######################################################
definf = {
    'need': 1,
    # 1 или 0: нужны ли сообщения (или пользователь отключил рассылку)
    'until': time() + yis * 32,
    # сколько хранить данные в секундах (во избежание переполнения базы данных
    'class': [],
    # список классов, на которые подписан пользователь
    'time': [],
    # список времён для оповещения (в секундах, с начала суток, лондонское
    # время)
    'ls': 0,
    # вермя, когда было отправлено последнее рассылочное сообщение пользователю
    'dis_empty': 1,
    # 1 или 0: верно ли что пользователь отключил пустые сообщения
    'lm': today()[2] - (0 if today()[1] > 5 else 1)
    # год, когда произошла ежегодная смена значения класса на 1 класс вверх,
    # по умолчанию ставится этот год если это начало года (перевода ещё не
    # было) и предыдущий, если конец (перевод был)
}
# список полей, которые должны содержаться в профиле каждого пользователя,
# а так же значения полей по умолчанию


if 1:
    tn = time()
    # tn содержит текущее время, во избежание вызова time() много раз (это может быть долго, а миллисекундная точность не важна)
    # пройти по списку пользователей и обновить информацию профиля
    for cdb in db:
        # cdb - текущий профиль (например, вк)
        for w in db[cdb]:
            # w - id пользователя
            # проходим по списку полей профиля и заполняем значениями по
            # умолчанию те, которых нет
            for e in definf:
                if e not in db[cdb][w]:
                    db[cdb][w][e] = definf[e]
            # если пора удалять информацию, это делается здесь.
            if tn > db[cdb][w]['until']:
                delete(db[cdb][w])
            # перевод всех на класс выше
            if today()[2] - db[cdb][w]['lm'] > 0 and today()[1] > 5:
                f = []
                for e in db[cdb][w]['class']:
                    i = ''
                    while e and e[0].isdigit():
                        i += e[0]
                        e = e[1:]
                    i = str(int(i) + 1)
                    e = i + e
                    f += [e]
                if db[cdb][w]['need']:
                    send(
                        'теперь вы подписаны классы: \n' +
                        ' '.join(f) +
                        '\nраньше вы были подписаны на классы: \n' +
                        ' '.join(
                            db[cdb][w]['class']) +
                        '\nЕсли вы завершили обучение в лицее, перейдите в настройки и отключите оповещения',
                        defkey,
                        w,
                        cdb)
                db[cdb][w]['class'] = f[:]
                db[cdb][w]['lm'] = today()[2]
#mainloop#########################################################
# бот ходит по этому циклу, пока не получит соообщения
    wai = []
    loopstart = time()
    # массив для сообщений
    while wai == []:
        tn = int(time())
        # нужно ли кого-то оповестить
        for cdb in db:
            for w in db[cdb].keys():
                if w.isdigit():
                    # проход по всем пользователям
                    for e in db[cdb][w]['time']:
                        # если с момента, когда надо было отправить сообщение
                        # прошло не более 5 минут и с последней рассылочной
                        # отправки прошло не менее 5 минут (не факт, что этот
                        # фрагмент кода выполнится именно в назначенное время,
                        # поэтому нужно допускать погрешность)
                        if 0 < tn % (24 * 3600) - int(e) < 300 and tn - \
                                db[cdb][w]['ls'] >= 300:
                            worked = work(db[cdb][w], db[cdb][w]['dis_empty'])
                            if worked:
                                send(worked, defkey, w, cdb)
                                db[cdb][w]['ls'] = int(time())
        wai = look()
        if wai == [] and tn - loopstart > 16:
            sleep(16)
#gotmess###########################################################
# сообщене получено
    shuffle(wai)
    for q in wai:
        # цикл по полученным сообщениям. Ниже рассматривается каждое. Формат: [автор (обычно id), текст, платформа(например вк)]
        # сначала нужно проверить верность профиля пользователя
        print(q)
        added = 0
        if q[2] not in db.keys():
            db[q[2]] = dict()
        if q[0] not in db[q[2]].keys():
            db[q[2]][q[0]] = dict()
            added = 1
        for w in definf:
            if w not in db[q[2]][q[0]]:
                db[q[2]][q[0]][w] = definf[w]
        profile = db[q[2]][q[0]]
        id = q[0]
        platform = q[2]
        text = q[1]
        # при присвоени словаря передаётся указатель на него а не копия
#logic###############################################################
# теперь можно приступать к пониманию, чего хотел пользователь
        if text == '':
            send('текстом, пожалуйста')
        elif text == 'json':
            send(str(db).replace("'", '"'))
        elif text == 'git':
            t = popen('git show').read()
            t = t.split('\n\n')[0]
            send(t)
        elif text == 'len':
            send(len(db[platform].keys()))
        elif text == 'sub':
            send(len([w for w in db[platform] if 'time' in db[platform]
                      [w] and db[platform][w]['time']]))
        elif text == '.':
            send('.')
        elif text == 'gl':
            send(globals())
        elif text == 'xg':
            send('\n'.join(['vk.com/id' + w + ' ' + str(db[platform][w])
                            for w in db[platform].keys()]))
        elif text == 'sw':
            send('\n'.join(['vk.com/id' +
                            w +
                            ' class: ' +
                            str(db[platform][w]['class'] if 'class' in db[platform][w] else 0) +
                            ' time: ' +
                            str([str(e //
                                     3600 +
                                     3) +
                                 ':' +
                                 str(e //
                                     60 %
                                     60) for e in (db[platform][w]['time'] if 'time' in db[platform][w] else [])]) for w in db[platform].keys()]))
        elif text == 'отмена':
            send('отменено')
        elif text in ['получить изменения', 'сейчас']:
            tmp = view()
            tmp = tmp
            send(tmp)
        elif text == 'отключить пустые сообщения' or text == 'пусто' and profile['dis_empty'] == 0:
            profile['dis_empty'] = 1
            send('теперь вам не будут приходить автоматические оповещения, если они не содержат изменений. Обратите внимание, что иногда вам всё же будут приходить пустые оповещения, сообщайте о таких ошибках и они будут исправлены.')
        elif text == 'включить пустые сообщения' or text == 'пусто' and profile['dis_empty'] == 1:
            profile['dis_empty'] = 0
            send('теперь вам будут приходить автоматические оповещения строго по расписанию, даже если в них ничего нет.')
        elif text == 'сообщение об ошибке':
            send('напишите сообщение об ошибке, начните его с символа $', backey)
        elif text[0] == '$':
            log('сообщение об ошибке\nавтор ' +
                getlink(id, platform) + '\n' + text[1:])
            send('спасибо за обращение. Именно благодаря вам этот сервис скоро станет лучше. сообщение отправлено администрации, с вами скоро свяжутся')
        elif text == 'lookall':
            send(work(profile))
        elif isdt(text):
            tmp = isdt(text)
            tmp = view(tmp[0], tmp[1], profile)
            tmp = '\n'.join(tmp)
            tmp = 'Изменения на ' + text + ':\n' + tmp
            send(tmp)
        elif iskcl(text):
            text = text.replace('\u2000', '')
            text = text.upper()
            profile['class'] = [text]
            send('теперь вы подписаны на класс ' + text)
        elif isktm(text):
            text = text.replace('\u205a', ':')
            ms = text
            text = text.split(':')
            text = (int(text[0]) - 3) % 24 * 3600 + int(text[1]) % 60 * 60
            profile['time'] = [text]
            send('теперь вы будете узнавать об изменениях в ' + ms)
        elif istm(text):
            ms = text
            text = text.split(':')
            text = (int(text[0]) - 3) % 24 * 3600 + int(text[1]) % 60 * 60
            if text in profile['time']:
                profile['time'] = [w for w in profile['time'] if w != text]
                t = 'количество оповещений в день уменьшено временем ' + ms
            else:
                if len(profile['time']) >= 256:
                    t = 'вы не можете получать более чем 256 уведомлений в сутки'
                else:
                    profile['time'] += [text]
                    t = 'количество оповещений в день увеличено временем ' + ms
            send(
                t +
                '. Обратие внимание, что оповещение не содержит изменений, опубликованных позднее, чем оно пришло')
        elif text in ['изменить кол-во оповещений в день', 'время']:
            ts = profile['time'][:]
            ts = [str((w // 3600 + 3) %
                      24) + ':' + str(w %
                                      3600 // 60) for w in ts]
            lts = len(ts)
            ts = '\n'.join(ts)
            if ts:
                ts = 'Сейчас вам приходят оповещения ' + str(lts) + ' раз в день по этому расписанию:\n' + ts + '''
введите интересующее вас время,
если оно в расписании, то оно будет убрано от туда,
если его там нет, то добавлено.
Бот не способен оповещать чаще, чем раз в 5 минут
'''
            else:
                ts = 'Сейчас вам не приходят оповещения, введите время для оповещения'
            send(ts, backey)
        elif text == 'указать класс':
            send('выберите свой класс', clskey)
        elif text == 'указать время':
            send('выберите, когда вас оповещать. Обратите внимание, что оповещение не содержит измений, опубликованных позднее. Любое время, которого здесь нет можно указать через расширенные настройки', timkey)
        elif text == 'настройки':
            send('панель настроек поможет настроить бота под себя', optkey)
        elif text == 'расширенные настройки':
            send(
                'панель настроек поможет более точно настроить бота под себя',
                setkey)
        elif text == 'help':
            send('''
чтобы изменить кол-во отслеживаемых классов напиши слово класс
чтобы изменить кол-во оповещений в день напиши слово время
чтобы получить изменения прямо сейчас напиши слово сейчас
чтобы включить или отключить пустые сообщения напиши слово пусто
чтобы сообщить об ошибке напиши сообщение, начав его с символа $
  ''')
        elif iscl(text):
            text = text.upper()
            ms = text
            if text in profile['class']:
                profile['class'] = [w for w in profile['class'] if w != text]
                t = 'количество отслеживаемых классов уменьшено классом ' + ms + '.'
            else:
                if len(profile['class']) >= 256:
                    t = 'вы не можете подписаться более чем на 256 классов'
                elif len(text) > 16:
                    t = 'длина класса не может превышать 16 символов'
                else:
                    profile['class'] += [text]
                    t = 'количество отслеживаемых классов увеличено классом  ' + ms + '.'
            send(t)
        elif text in ['изменить кол-во отслеживаемых классов', 'класс']:
            ts = profile['class'][:]
            lts = len(ts)
            ts = '\n'.join(ts)
            if ts:
                send(
                    'Сейчас вы подписаны на ' +
                    str(lts) +
                    ' классов:\n' +
                    ts +
                    '\n Введите класс, который вас интересует, если вы подписаны на него, то будете отписаны, если подписаны не были, то будете подписаны. Вводить класс следует указав номер и букву без пробела, если в параллели один класс, то это класс "а". Используйте только русские буквы, а не их латинские аналоги',
                    backey)
            else:
                send('Сейчас вы не подписаны ни на один из классов. Введите класс, на который хотите подписаться.  Вводить класс следует узазав номер и букву без пробела, если в параллели один класс, то это класс "а". Используйте только русские буквы, а не их латинские аналоги', backey)
        elif text == 'отключить рассылку':
            profile['until'] = time() + yis
            profile['need'] = 0
            send('рассылка отключена, однако, вы всё ещё можете получать изменения по нажатии на кнопку. Если вы не включите её в течение года, информация о ваших настройках бота будет удаена')
        elif text == 'включить рассылку':
            profile['need'] = 1
            profile['until'] = time() + yis * 32
            send('рассылка включена')
        else:
            send('''Привет, это бот-оповещатель об изменениях в расписании.
Бота надо настроить, чтобы он знал, в каком вы классе и во сколько вас оповещать.
Для этого укажи, сколько раз в день тебе сообщать об изменениях, и за изменениями для каких классов ты хочешь следить.
Клавиатура поможет тебе в этом.
если твоё приложение не поддерживает работу с клавиатурами, то напиши мне команду help
''')
# запись базы данных после успешного завершения программы
open('../kpml.bot.db.json', 'w').write(dumps(db))
